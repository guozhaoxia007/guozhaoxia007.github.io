<!DOCTYPE html>
<html lang="en-us">
<head>
<meta charset="utf-8">
<meta name="description" content="">
<meta name="keywords" content="">
<meta name="author" content="">
<meta name="generator" content="Hugo 0.15" />
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="http://guozhaoxia007.github.io/css/style.css" type="text/css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400,700" type="text/css">
<link rel="alternate" href="http://guozhaoxia007.github.io/index.xml" type="application/rss+xml" title="喵大人">
<title>函数式编程 - 喵大人</title>
</head>
<body>

<header>
  <div class="container">
    <a class="path" href="http://guozhaoxia007.github.io/">[喵大人]</a>
    <span class="caret">Blog</span>
  </div>
</header>

<div class="container">


<main role="main" class="article">
  
<article class="single" itemscope itemtype="http://schema.org/BlogPosting">
  <div class="meta">

    <span class="key">published on</span>
    <span class="val"><time itemprop="datePublished" datetime="2016-02-21">February 21, 2016</time></span>



  </div>
  <h1 class="headline" itemprop="headline">函数式编程</h1>
  <section class="body" itemprop="articleBody">
    

<h1 id="函数式编程:7bd27318b7533519c78b954d5b372338">函数式编程</h1>

<h2 id="高阶函数:7bd27318b7533519c78b954d5b372338">高阶函数</h2>

<pre><code class="language-python">def add(x, y, f):
    return f(x) + f(y)
    
&gt;&gt;&gt; add(-3, 2, abs)
5
&gt;&gt;&gt; map(abs, [1, -2, -5])
[1, 2, 5]
</code></pre>

<p>常见的内置高阶函数
map/filter/reduce/sorted</p>

<h2 id="返回函数:7bd27318b7533519c78b954d5b372338">返回函数</h2>

<pre><code class="language-python">def f():
    print 'call f()...'
    # 定义函数g:
    def g():
        print 'call g()...'
    # 返回函数g:
    return g

&gt;&gt;&gt; x = f()   # 调用f()
call f()...
&gt;&gt;&gt; x   # 变量x是f()返回的函数：
&lt;function g at 0x1037bf320&gt;
&gt;&gt;&gt; x()   # x指向函数，因此可以调用
call g()...   # 调用x()就是执行g()函数定义的代码
</code></pre>

<p>延迟计算</p>

<h2 id="闭包:7bd27318b7533519c78b954d5b372338">闭包</h2>

<pre><code class="language-python">def f():
    print 'f()...'
    def g():
        print 'g()...'
    return g

# 希望一次返回3个函数，分别计算1x1,2x2,3x3:
def count():
    fs = []
    for i in range(1, 4):
        def f():
            return i*i
        fs.append(f)
    return fs

f1, f2, f3 = count()
</code></pre>

<h2 id="匿名函数:7bd27318b7533519c78b954d5b372338">匿名函数</h2>

<pre><code class="language-python">&gt;&gt;&gt; map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9])
[1, 4, 9, 16, 25, 36, 49, 64, 81]

&gt;&gt;&gt; sorted([1, 3, 9, 5, 0], lambda x,y: -cmp(x,y))
[9, 5, 3, 1, 0]

&gt;&gt;&gt; myabs = lambda x: -x if x &lt; 0 else x 
&gt;&gt;&gt; myabs(-1)
1
&gt;&gt;&gt; myabs(1)
1
</code></pre>

<h2 id="decorator装饰器:7bd27318b7533519c78b954d5b372338">decorator装饰器</h2>

<pre><code class="language-python">&gt;&gt;&gt; def f1(x):
...     return x * x
...
&gt;&gt;&gt; def f2(x):
...     return x * 2
...
&gt;&gt;&gt; def new_fn(f):
...     def fn(x):
...         print 'call ' + f.__name__ + '()'
...         return f(x)
...     return fn
...
&gt;&gt;&gt; g2 = new_fn(f2)
&gt;&gt;&gt; g2(5)
call f2()
10
&gt;&gt;&gt;
&gt;&gt;&gt; @new_fn
... def f1(x):
...     return x * 2
...
&gt;&gt;&gt; f1(5)
call f1()
10
</code></pre>

<p>Q1: 如果被装饰的函数函数个数不一样怎么办</p>

<pre><code class="language-python">import time

def performance(f):
    def fn(*args, **kw):
        t1 = time.time()
        r = f(*args, **kw)
        t2 = time.time()
        print 'call %s() in %fs' % (f.__name__, (t2 - t1))
        return r
    return fn

performance
def factorial(n):
    return reduce(lambda x,y: x*y, range(1, n+1))

print factorial(10)
</code></pre>

<p>带参数的decorator, @log(&ldquo;INFO&rdquo;)</p>

<pre><code class="language-python">def log(prefix):
    def log_decorator(f):
        def wrapper(*args, **kw):
            print '[%s] %s()...' % (prefix, f.__name__)
            return f(*args, **kw)
        return wrapper
    return log_decorator

@log('DEBUG')
def test():
    pass
print test()
</code></pre>

<pre><code class="language-python">import time

def performance(unit):
    def performance_decorator(f):
        def wrapper(*args, **kw):
            t1 = time.time()
            r = f(*args, **kw)
            t2 = time.time()
            t = (t2 - t1) * 1000 if unit == 'ms' else (t2 - t1)
            print 'call %s() in %f %s' % (f.__name__, t, unit)
            return r
        return wrapper
    return performance_decorator

@performance('ms')
def factorial(n):
    return reduce(lambda x,y: x*y, range(1, n+1))

print factorial(10)
</code></pre>

<h2 id="完善decorator:7bd27318b7533519c78b954d5b372338">完善decorator</h2>

<pre><code class="language-python">import functools
def log(f):
    @functools.wraps(f)
    def wrapper(*args, **kw):
        print 'call...'
        return f(*args, **kw)
    return wrapper
</code></pre>

<h2 id="偏函数:7bd27318b7533519c78b954d5b372338">偏函数</h2>

  </section>
</article>

</main>


</div>

<footer>
  <div class="container">
    <span class="copyright">&copy; 2016  喵大人 - <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a></span>
  </div>
</footer>

</body>
</html>

