<!DOCTYPE html>
<html lang="en-us">
<head>
<meta charset="utf-8">
<meta name="description" content="">
<meta name="keywords" content="">
<meta name="author" content="">
<meta name="generator" content="Hugo 0.15" />
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="http://guozhaoxia007.github.io/css/style.css" type="text/css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400,700" type="text/css">
<link rel="alternate" href="http://guozhaoxia007.github.io/index.xml" type="application/rss+xml" title="喵大人">
<title>Posts - 喵大人</title>
</head>
<body>

<header>
  <div class="container">
    <a class="path" href="http://guozhaoxia007.github.io/">[喵大人]</a>
    <span class="caret">Blog</span>
  </div>
</header>

<div class="container">

<main role="main" class="article-list">
  <h1 class="list-title">Posts</h1>
  
    
<article class="list-item" itemscope itemtype="http://schema.org/Blog">
  <h2 class="headline" itemprop="headline"><a href="/post/2016/02/functional_programming/">函数式编程</a></h2>
  <div class="meta">

    <span class="key">published on</span>
    <span class="val"><time itemprop="datePublished" datetime="2016-02-21">February 21, 2016</time></span>

  </div>
  <section class="summary">
    函数式编程 高阶函数 def add(x, y, f): return f(x) + f(y) &gt;&gt;&gt; add(-3, 2, abs) 5 &gt;&gt;&gt; map(abs, [1, -2, -5]) [1, 2, 5] 常见的内置高阶函数 map/filter/reduce/sorted 返回函数 def f(): print 'call f()...' # 定义函数g: def g(): print 'call g()...' # 返回函数g: return g &gt;&gt;&gt; x = f() # 调用f() call f()... &gt;&gt;&gt; x # 变量x是f()返回的函数： &lt;function g at 0x1037bf320&gt; &gt;&gt;&gt; x() # x指向函数，因此可以调用 call g()... # 调用x()就是执行g()函数定义的代码 延迟计算 闭包 def f(): print 'f()...' def g(): print 'g()...' return g # 希望一次返回3个函数，分别计算1x1,2x2,3x3: def count(): fs = [] for i in range(1, 4): def f(): return i*i fs.append(f) return fs f1, f2, f3 = count() 匿名函数 &gt;&gt;&gt; map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9]) [1, 4, 9, 16, 25, 36, 49, 64, 81] &gt;&gt;&gt; sorted([1, 3, 9, 5, 0], lambda x,y: -cmp(x,y)) [9, 5, 3, 1, 0] &gt;&gt;&gt; myabs = lambda x: -x if x &lt; 0 else x &gt;&gt;&gt; myabs(-1) 1 &gt;&gt;&gt; myabs(1) 1 decorator装饰器 &gt;&gt;&gt; def f1(x): ...  <a href="/post/2016/02/functional_programming/">Read More...</a>
  </section>
</article>

  
    
<article class="list-item" itemscope itemtype="http://schema.org/Blog">
  <h2 class="headline" itemprop="headline"><a href="/post/2016/02/pytz/">pytz</a></h2>
  <div class="meta">

    <span class="key">published on</span>
    <span class="val"><time itemprop="datePublished" datetime="2016-02-20">February 20, 2016</time></span>

  </div>
  <section class="summary">
    pytz使用 使用场景 查询，如果前端输入start_time, end_time，后台计算月报（每天开始结束时间）和年报（每月开始结束时间） 定时任务，统计前一天的数据，即知道年月日，后台计算start_time, end_time 实验1，夏令时和冬令时 # 美东、中国标准、印度标准、印尼西部 ['UTC', 'US/Eastern', 'Asia/Shanghai', 'Asia/Kolkata', 'Asia/Jakarta'] fmt = '%Y-%m-%d %H:%M:%S %Z%z' for tz in timezones: p_tz = timezone(tz) loc_dt = p_tz.localize(datetime(2015,4,1,8,0,0)) print loc_dt.strftime(fmt) 2015-04-01 08:00:00 EDT-0400 2015-04-01 08:00:00 CST+0800 2015-04-01 08:00:00 IST+0530 2015-04-01 08:00:00 WIB+0700 for tz in timezones: p_tz = timezone(tz) loc_dt = p_tz.localize(datetime(2015,12,1,8,0,0)) print loc_dt.strftime(fmt) 2015-12-01 08:00:00 EST-0500 2015-12-01 08:00:00 CST+0800 2015-12-01 08:00:00 IST+0530 2015-12-01 08:00:00 WIB+0700 实验2 In [146]:  <a href="/post/2016/02/pytz/">Read More...</a>
  </section>
</article>

  
</main>

</div>

<footer>
  <div class="container">
    <span class="copyright">&copy; 2016  喵大人 - <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a></span>
  </div>
</footer>

</body>
</html>

