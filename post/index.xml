<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 喵大人的博客</title>
    <link>http://guozhaoxia007.github.io/post/</link>
    <description>Recent content in Posts on 喵大人的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Thu, 08 Feb 2018 15:07:13 +0800</lastBuildDate>
    
	<atom:link href="http://guozhaoxia007.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>postgis</title>
      <link>http://guozhaoxia007.github.io/post/2018/02/date-line/</link>
      <pubDate>Thu, 08 Feb 2018 15:07:13 +0800</pubDate>
      
      <guid>http://guozhaoxia007.github.io/post/2018/02/date-line/</guid>
      <description>The date-line and the poles 今天看postgis文档时，说到所有球形形状的计算都不涉及date-line和poles的概念。那么date-line和poles到底是什么，有什么影响？
先说poles，比较简单，也就是地理极点。对于地球来说就是南极点与北极点。南北极点是唯一的，也比较好确认，也就是行星、卫星或其它较大天体的自转轴与其表面交会的点。
确定了南北极点，那么纬线也就确认了，0纬线也就是赤道线，与自转轴垂直，往南就是南纬，往北就是北纬，由于赤道与自转轴是垂直关系，所以角度最大是90度，即南纬最大90度，北纬最大90度。看图： 确定了纬线，那么就可以找经线了，经线与纬线是垂直的。也就是，纬线瓜分南北半球，经线瓜分东西半球。那么问题来了，0经线是哪里？在地球上每个国家都把太阳升起的时间当作一天的开始，地球被太阳光照射的半个球面形成白昼，而背着太阳光的另外半个球面便是黑夜。但是由于各国家分布在地球各个地方，加上自转，所以见到太阳的时间是不一样的。讲道理的话，任何一条经线都可以称为0经线，但是这样的话，全球时间就不能统一了。所以后来规定了本初子午线（子午线即经线）作为0经线，它经过了格林威治天文台，本初子午线的对面即180经线就是国际日界线，即国际日期变更线（经过这条线后日期要变），当然为了避免同一国家出现2个日期，所以这条线不是直线，而是绕过一些岛屿啥的，是经过了太平洋的一条折线。
概念都清楚了，那么这些线对地球人有什么影响呢？最大的影响就是日期与时间的统一。
“区时系统”规定，地球上每15°经度范围作为一个时区（即太阳1个小时内走过的经度）。 这样，整个地球的表面就被划分为24个时区。各时区的“中央经线”规定为0°（即“本初子午线”）、东西经15°、东西经30°、东西经45°……直到180°经线，在每条中央经线东西两侧各7.5°范围内的所有地点，每一时区都按它的中央子午线来计量时间，即采用它的中央子午线的地方平时，叫做标准时。所以地球上只有24种不同时刻的存在。本初子午线上的地方如果是下午12点，那么在地球背面的地方就是子夜12点。 有了时区系统，问题又来了，假如你坐飞机从西往东越过了日界线，每跨越一个时区，就会把你的表向前拨一个小时加上你旅行消耗的时间，这样当你跨越24个时区回到原地后，你的表比身边的人快了24个小时；相反，当你由东向西周游世界一圈后，你的表就比别人慢24个小时。
当你在从东向西的航行中,因为你是在追赶太阳,所以就感到白天“加长”了；相反,当你从西向东航行时、由于是背离太阳、所以就好像有点白天“短”了的感觉.这样,你就往往会记错日子,把日历翻错.为了避免这种不方便,1884年起人们决定在太平洋中,也即在东经180度经线附近划一条线,规定当各种交通工具自东向西越过此线后,日期增加1天（例如,由7月31日改为8月1日〕,而由西向东越过此线后,日期减少1天（例如, 由8月1日日改为7月31）</description>
    </item>
    
    <item>
      <title>postgis</title>
      <link>http://guozhaoxia007.github.io/post/2018/02/postgis/</link>
      <pubDate>Wed, 07 Feb 2018 15:07:13 +0800</pubDate>
      
      <guid>http://guozhaoxia007.github.io/post/2018/02/postgis/</guid>
      <description>Chapter 4. Using PostGIS: Data Management and Queries http://postgis.net/docs/manual-2.3/using_postgis_dbmanagement.html
4.1. GIS Objects 4.1.1. OpenGIS WKB and WKT OpenGIS定义了两种空间表达对象：the Well-Known Text(WKT) form和the Well-Known Binary(WKB) form. WKT和WKB都包含了对象的类型和坐标。
WKT举例：
 POINT(0 0)
LINESTRING(0 0,1 1,1 2)
POLYGON((0 0,4 0,4 4,0 4,0 0),(1 1, 2 1, 2 2, 1 2,1 1))
MULTIPOINT((0 0),(1 2))
MULTILINESTRING((0 0,1 1,1 2),(2 3,3 2,5 4))
MULTIPOLYGON(((0 0,4 0,4 4,0 4,0 0),(1 1,2 1,2 2,1 2,1 1)), ((-1 -1,-1 -2,-2 -2,-2 -1,-1 -1)))</description>
    </item>
    
    <item>
      <title>postgis-2</title>
      <link>http://guozhaoxia007.github.io/post/2018/02/postgis-2/</link>
      <pubDate>Wed, 07 Feb 2018 15:07:13 +0800</pubDate>
      
      <guid>http://guozhaoxia007.github.io/post/2018/02/postgis-2/</guid>
      <description>0. 创建空间字段准备 CREATE EXTENSION postgis;  -- Geometry -- Method 1 SELECT AddGeometryColumn (&#39;scheme&#39;，&#39;cities&#39;, &#39;the_geom&#39;, 4326, &#39;POINT&#39;, 2); AddGeometryColumn( &amp;lt;schema_name&amp;gt;, &amp;lt;table_name&amp;gt;, &amp;lt;column_name&amp;gt;, &amp;lt;srid&amp;gt;, &amp;lt;type&amp;gt;, &amp;lt;dimension&amp;gt; ) -- Method 2 CREATE TABLE ROADS ( ID int4, ROAD_NAME varchar(25), geom geometry(LINESTRING,4326) ); CREATE TABLE global_points ( id SERIAL PRIMARY KEY, name VARCHAR(64), location GEOGRAPHY(POINT,4326) ); -- Method 3 ALTER TABLE roads ADD COLUMN geom2 geometry(LINESTRINGZ,4326);  -- geography CREATE TABLE testgeog(gid serial PRIMARY KEY, the_geog geography(POINT,4326) ); CREATE TABLE testgeog(gid serial PRIMARY KEY, the_geog geography(POINTZ,4326) );  1.</description>
    </item>
    
    <item>
      <title>Python-ORM</title>
      <link>http://guozhaoxia007.github.io/post/2016/04/python-orm/</link>
      <pubDate>Wed, 13 Apr 2016 16:05:10 +0800</pubDate>
      
      <guid>http://guozhaoxia007.github.io/post/2016/04/python-orm/</guid>
      <description>list     SQLALchemy Orator Peewee     orm Y Y Y   sql builder Y Y Y   schema builder Y Y Y   raw sql Y Y Y   transaction Y Y Y   读写分离 Y Y Y   connection pool Y multi connection Y   extensions simple Validators(event listener)&amp;hellip; Cache, to json model to dict    demos https://github.</description>
    </item>
    
    <item>
      <title>成都一年</title>
      <link>http://guozhaoxia007.github.io/post/2016/03/%E6%88%90%E9%83%BD%E4%B8%80%E5%91%A8%E5%B9%B4/</link>
      <pubDate>Thu, 03 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>http://guozhaoxia007.github.io/post/2016/03/%E6%88%90%E9%83%BD%E4%B8%80%E5%91%A8%E5%B9%B4/</guid>
      <description>梦里不知身是客</description>
    </item>
    
    <item>
      <title>mysql分表</title>
      <link>http://guozhaoxia007.github.io/post/2016/02/mysql_merge/</link>
      <pubDate>Wed, 24 Feb 2016 11:08:29 +0800</pubDate>
      
      <guid>http://guozhaoxia007.github.io/post/2016/02/mysql_merge/</guid>
      <description>需求  提高插入查询速度 便于归档  数据容量估算 5k终端，单个终端1分钟4个点，假设1天运行12小时，5000终端1天将产生：4 * 60 * 12 * 5000 = 14400000条记录，一条记录82bytes
即一天产生：14400000 * 82 = 1180800000bytes = 1126.1 M = 1.1 G 即一月产生：4亿条记录，30G存储
根据容量估算，除去查询效率不考虑外，单是存储问题就很严重，1w终端单月产生8亿60G，10w终端单月产生80亿600G。
产品调研  oneproxy
 优点：
 对应用透明 支持二级分表(tid, timestamp) 多种分表方法(hash, range) 使用简单方便 性能测试，大大提高查询速度，插入速度也不会大的影响 由于使用时间分表，极大方便归档   缺点：
 需手动创建子表   mysql merge
 优点：
 对应用透明 无需引入第三方软件   缺点：
 子表需为MyISAM引擎 无法使用表字段分表（即无法使用时间分表，只能人工分表） 需手动创建子表 一级分表 MERGE storage engine. User-defined partitioning and the MERGE storage engine are not compatible.</description>
    </item>
    
    <item>
      <title>hugo</title>
      <link>http://guozhaoxia007.github.io/post/2016/02/hugo/</link>
      <pubDate>Mon, 22 Feb 2016 19:21:24 +0800</pubDate>
      
      <guid>http://guozhaoxia007.github.io/post/2016/02/hugo/</guid>
      <description>启动本地server  hugo server -t hugo-base16-theme
 生成静态文件到public, baseUrl可以在.git中配置  hugo -t hugo-base16-theme &amp;ndash;baseUrl=&amp;ldquo;http://guozhaoxia007.github.io&amp;quot;</description>
    </item>
    
    <item>
      <title>python IDE</title>
      <link>http://guozhaoxia007.github.io/post/2016/02/python-ide/</link>
      <pubDate>Mon, 22 Feb 2016 15:48:44 +0800</pubDate>
      
      <guid>http://guozhaoxia007.github.io/post/2016/02/python-ide/</guid>
      <description>VIM 1. 参考链接： https://github.com/yangyangwithgnu/use_vim_as_ide https://github.com/spf13/spf13-vim
2. install sudo pip install pyflakes
sudo pip install pylint
sudo pip install pep8
或者使用这个vim插件
https://github.com/scrooloose/syntastic
3. 我的vimrc call pathogen#infect() syntax enable syntax on set background=dark set number set tabstop=4 set softtabstop=4 set shiftwidth=4 set expandtab set laststatus=2 set ruler &amp;quot; set cursorcolumn &amp;quot; 突出显示当前列 set cursorline &amp;quot; 突出显示当前行 set hlsearch set incsearch set ignorecase set autoindent set nowrap set showcmd &amp;quot; 显示输入命令 let g:solarized_termcolors=16 colorscheme solarized set textwidth=79 autocmd FileType text setlocal textwidth=78 &amp;quot; 一旦一行的字符超出79个的话就把那些字符的背景设为红色 highlight OverLength ctermbg=red ctermfg=white guibg=#592929 match OverLength /\%80v.</description>
    </item>
    
    <item>
      <title>函数式编程</title>
      <link>http://guozhaoxia007.github.io/post/2016/02/functional_programming/</link>
      <pubDate>Sun, 21 Feb 2016 01:09:41 +0800</pubDate>
      
      <guid>http://guozhaoxia007.github.io/post/2016/02/functional_programming/</guid>
      <description>函数式编程 高阶函数 def add(x, y, f): return f(x) + f(y) &amp;gt;&amp;gt;&amp;gt; add(-3, 2, abs) 5 &amp;gt;&amp;gt;&amp;gt; map(abs, [1, -2, -5]) [1, 2, 5] 常见的内置高阶函数 map/filter/reduce/sorted
返回函数 def f(): print &amp;#39;call f()...&amp;#39; # 定义函数g: def g(): print &amp;#39;call g()...&amp;#39; # 返回函数g: return g &amp;gt;&amp;gt;&amp;gt; x = f() # 调用f() call f()... &amp;gt;&amp;gt;&amp;gt; x # 变量x是f()返回的函数： &amp;lt;function g at 0x1037bf320&amp;gt; &amp;gt;&amp;gt;&amp;gt; x() # x指向函数，因此可以调用 call g()... # 调用x()就是执行g()函数定义的代码 延迟计算
闭包 def f(): print &amp;#39;f().</description>
    </item>
    
    <item>
      <title>pytz</title>
      <link>http://guozhaoxia007.github.io/post/2016/02/pytz/</link>
      <pubDate>Sat, 20 Feb 2016 23:18:34 +0800</pubDate>
      
      <guid>http://guozhaoxia007.github.io/post/2016/02/pytz/</guid>
      <description>pytz使用 使用场景  查询，如果前端输入start_time, end_time，后台计算月报（每天开始结束时间）和年报（每月开始结束时间） 定时任务，统计前一天的数据，即知道年月日，后台计算start_time, end_time  实验1，夏令时和冬令时 # 美东、中国标准、印度标准、印尼西部 [&#39;UTC&#39;, &#39;US/Eastern&#39;, &#39;Asia/Shanghai&#39;, &#39;Asia/Kolkata&#39;, &#39;Asia/Jakarta&#39;] fmt = &#39;%Y-%m-%d %H:%M:%S %Z%z&#39; for tz in timezones: p_tz = timezone(tz) loc_dt = p_tz.localize(datetime(2015,4,1,8,0,0)) print loc_dt.strftime(fmt) 2015-04-01 08:00:00 EDT-0400 2015-04-01 08:00:00 CST+0800 2015-04-01 08:00:00 IST+0530 2015-04-01 08:00:00 WIB+0700 for tz in timezones: p_tz = timezone(tz) loc_dt = p_tz.localize(datetime(2015,12,1,8,0,0)) print loc_dt.strftime(fmt) 2015-12-01 08:00:00 EST-0500 2015-12-01 08:00:00 CST+0800 2015-12-01 08:00:00 IST+0530 2015-12-01 08:00:00 WIB+0700  实验2 In [146]: now = int(time.</description>
    </item>
    
  </channel>
</rss>